using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Newtonsoft.Json;
using NLog;

namespace BRClib
{
    using Env = Environment;

    public static class Global
    {
        public static void Init(bool portableMode)
        {
            _baseDir = portableMode ? AppDomain.CurrentDomain.BaseDirectory :
                Path.Combine(Env.GetFolderPath(Env.SpecialFolder.ApplicationData),
                             "BlenderRenderController");

            _scriptsDir = Path.Combine(_baseDir, "scripts");
            _configFilePath = Path.Combine(_baseDir, SETTINGS_FILE);

            Directory.CreateDirectory(_scriptsDir);

            GetProjInfoScript = Path.Combine(_scriptsDir, PyGetProjInfo);
            MixdownScript = Path.Combine(_scriptsDir, PyMixdownAudio);

            var fw = ScriptsToDisk();
            Trace.WriteLine(fw + " scripts written to disk");

            Settings = Load(_configFilePath);
            NlogSetup(portableMode);
        }


        public static ConfigModel Settings { get; private set; }

        public static string GetProjInfoScript { get; private set; }
        public static string MixdownScript { get; private set; }

        public static void SaveSettings()
        {
            SaveInternal(Settings, _configFilePath);
        }

        public static bool CheckProgramPaths()
        {
            bool blenderFound = true, ffmpegFound = true;
            string ePath;

            if (!File.Exists(Settings.BlenderProgram))
            {
                ePath = FindProgram("blender");
                blenderFound = ePath != null;

                if (blenderFound) Settings.BlenderProgram = ePath;
            }

            if (!File.Exists(Settings.FFmpegProgram))
            {
                ePath = FindProgram("ffmpeg");
                ffmpegFound = ePath != null;

                if (ffmpegFound) Settings.FFmpegProgram = ePath;
            }

            return blenderFound && ffmpegFound;
        }

        // workaround Process.Start not working on .NET core
        public static void ShellOpen(string file_uri)
        {
            var stInfo = new ProcessStartInfo(file_uri) {
                UseShellExecute = true
            };
            Process.Start(stInfo);
        }


        static string _baseDir, _scriptsDir, _configFilePath;

        const string SETTINGS_FILE = "brc_settings.json";
        const string PyGetProjInfo = "get_project_info.py";
        const string PyMixdownAudio = "mixdown_audio.py";


        public static string FindProgram(string name, params string[] morePaths)
        {
            if (Env.OSVersion.Platform == PlatformID.Win32NT)
            {
                name += ".exe";
            }

            var EnvPATH = Env.GetEnvironmentVariable("PATH").Split(Path.PathSeparator);
            var searchPath = new List<string>(EnvPATH.Length + 1);
            searchPath.Add(AppDomain.CurrentDomain.BaseDirectory);
            searchPath.AddRange(EnvPATH);
            searchPath.AddRange(morePaths);

            var found = searchPath.Select(p => Path.Combine(p, name)).FirstOrDefault(File.Exists);

            return found;
        }

        static int ScriptsToDisk()
        {
            var assembly = Assembly.GetExecutingAssembly();
            var assembName = assembly.GetName().Name;
            var resourcesStuff = new Dictionary<string, string>
            {
                [GetProjInfoScript] = assembName + ".Scripts." + PyGetProjInfo,
                [MixdownScript] = assembName + ".Scripts." + PyMixdownAudio
            };

            // Write files to disk if they don't exist, or are diferent
            int filesWritten = 0;
            var md5 = System.Security.Cryptography.MD5.Create();
            byte[] header = Encoding.UTF8.GetBytes("# Generated by BRC, do not modify!\n");

            foreach (var pair in resourcesStuff)
            {
                var filePath = pair.Key;
                var resPath = pair.Value;

                using (Stream assmbStream = assembly.GetManifestResourceStream(resPath), memStream = new MemoryStream())
                using (var fs = File.Open(filePath, FileMode.OpenOrCreate, FileAccess.ReadWrite))
                {
                    // write header to embedded stream
                    memStream.Write(header, 0, header.Length);
                    assmbStream.CopyTo(memStream);
                    memStream.Position = 0;

                    bool eq = md5.ComputeHash(fs).SequenceEqual(md5.ComputeHash(memStream));
                    if (!eq)
                    {
                        memStream.Position = 0;
                        fs.Position = 0;

                        memStream.CopyTo(fs);
                        filesWritten++;
                    }
                }
            }

            return filesWritten;
        }

        static string GetTempName()
        {
            return Path.Combine(Path.GetTempPath(), Path.GetRandomFileName() + ".py");
        }

        static ConfigModel Load(string configFile)
        {
            if (File.Exists(configFile))
            {
                return JsonConvert.DeserializeObject<ConfigModel>(File.ReadAllText(configFile));
            }

            // create file w/ default settings
            var def = new ConfigModel();
            SaveInternal(def, configFile);

            return def;
        }

        static void SaveInternal(ConfigModel def, string filepath)
        {
            var json = JsonConvert.SerializeObject(def, Formatting.Indented);
            File.WriteAllText(filepath, json);
        }

        static void NlogSetup(bool portableMode)
        {
            LogLevel lLvl;

            switch (Settings.LoggingLevel)
            {
                case 1: lLvl = LogLevel.Info; break;
                case 2: lLvl = LogLevel.Trace; break;
                default: return;
            }

            string fileTgt = "brclogfile";
            if (portableMode) fileTgt += "_p";

            var target = LogManager.Configuration.FindTargetByName(fileTgt);
            LogManager.Configuration.AddRule(lLvl, LogLevel.Fatal, target, "*");

            LogManager.ReconfigExistingLoggers();
        }

    }
}
